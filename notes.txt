Notes on revamping chessic 24-06-2022

We should put the archived version into a new git repository and
give it a new name.
Then we should start to use it as it to train the Grunfeld.

At the same time, clone it somewhere else and create branches for
the following upgrades:

1) Replaced constants with an enum
2) Subclass Board and put the printing functions into that class.
   Also write unit tests for that class.
3) Create the whole OOP architecture class by class, from the
   inside out. So we should have classes like:
   - Problem, Solution, which subclass Node
   - Card
   - Item, Collection, Category
   - MainMenu, CollectionMenu, CategoryMenu which subclass Menuxo
4) Have a choice of colour schemes, a layer of abstraction between ZugSquareColours,
   ZugPieceColoours and the Colorama Back.CYAN, Fore.WHITE etc.
5) Default values (such as new_remaing, new_limit, etc) should be set in config and read
   on start up
~~~~~~~~~~~~~~~~
2022-06-24 18:52

I'm going to do 2, creating my own board class, and write unit tests
at the same time.
So we need a venv.

~~~~~~~~~~~~~~~~
2022-06-25 23:06

Yesterday, I got the ZugBoard class functioning. It uses a chess.Board by composition,
allowing the wrapping of chess.Board to be performed outside of the chess library.

I'm going to follow the same design pattern now when wrapping the nodes.
I'll start with the problem class, as problems have no training data, so it should be
easier.

The queue architecture looks clunky, perhaps some of the design was chosen due to issues with pickle.
It should be as simple as possible.
We work with nodes. There are three kinds of nodes:

1. Root
2. Problem
3. Solution

The root has associated metadata
A solution has associated training data.
A Problem has no associated data, but may or may not have a corresponding solution.

The root object is created and used during Python execution, the metadata itself is
translated via the node's comment, which is stored in the PGN.
Similarly for solutions.
So these classes are temporary wrappers.

~~~~~~~~~~~~~~~~
2022-06-26 01:06

Created some infrastructre for the ZugRoot class.
The next job is to factor out the repeated code in test_ZugRoot.py into fixtures.

~~~~~~~~~~~~~~~~
2022-07-25 23:06

Did some work with the fixtures.
I tried refactoring the data classes with an embedded dict in order to use iterables
to replace the places where we list all the data fields.
That didn't work so well because you have to process date fields and int fields
differently whenever you use the iterable.
Perhaps there is a better solution for this; but let's have a think.

The point of using classes like this is that refactoring should be limited to a single
class..

~~~~~~~~~~~~~~~~
2022-07-26 00:58

Spent a long time going round in circles with pytest;
putting fixtures into conftest.py then taking them out;
using macros for test values and then erasing them;
and so on..

What is the lesson to learn here?
Always have a clear vision of the next step.
Only move on to the next step when the current basis is capable of accommodating it.
If you start to go round in circles - stop.
Have a long break, and figure out what is the root cause of the problem.

Here the root cause was that I was reluctant to put tests for two separate classes
into a single test file.
But this was a little irrational.
The second class is only defined for composition into the first.
So naturally, the tests and fixtures for the second class belong with those of the first.

I think the code is in a decent state now.

The next steps are:
1. Implement error handling for the Zug*Data classes for badly formatted strings.
2. Figure out how these classes will be used, and hence what extra methods they may need
3. Look into @property and write setter methods for the data class properties.

~~~~~~~~~~~~~~~~
2022-07-29 23:03

I'm going to write the Queue class.

~~~~~~~~~~~~~~~~
2022-07-30 10:05

Writing the queue class did not go swimmingly.
It would have been better to write all of the unit tests for the queue class first.
That would have defined the class.
Rather than doing incremental TDD.

~~~~~~~~~~~~~~~~
2022-07-30 10:05

I believe that _handle_result() is not necessarily the best option.
The result returned should tell play() whether or not to reinsert, and if so where.
Perhaps what we need is interpret_result() - or rather result.interpret().
The distinction is important.
Probably it should be interpret_result().
A result should not know anything about a queue.
How the result should be requeued is really a property of the type of learning,
or the manner of learning.
So perhaps the ZugQueue is really a ZugLearningQueue which employs a strategy
to handle how learning results guide reinsertion.

However, this could also depend on the state of the QueueItem
(for example Solution status in position-based learning)
so it's not clear.
Perhaps the item should handle it's result and instruct the queue where it is to
be inserted.
Yes, I think so.

Let's have play return an integer queue position if it's to be reinserted;
or None otherwise.

~~~~~~~~~~~~~~~~
2022-07-30 22:55

Next up, I'm going to write a suite of tests for the training position class.
I think I should stick with the convention of only testing the public functions.

So the point is that I'll test only play().
ZugTrainingPosition will have a chess.ChildNode as a read-only variable.
The test should check that its comment is updated correctly.

Right, the test should test the side effect that play() has on the chess.node.
So that node remains as a private member variable. It is created outside of the tested
function.
So it should be created by the test, passed to the item constructor, and its state
after the function finishes asserted.

Now I have a situation where there are a lot of private member functions mocked out.
They are all called by the private member function _present().
Perhaps this suggests that that function should be handled by a separate class.

Yes I think so: ZugTrainingPositionPresenter.
But let's see how it look without doing that.

~~~~~~~~~~~~~~~~
2022-07-30 22:55

Factoring out the presenter role into a class has worked perfectly.
That should be noted, it has really eased the burden of testing the TrainingPosition
class.

Next, we need to look further at the use of dates and fixtures in the tests.
In fact, there should really only be two tests now:
1. the invalid state
2. the learning phase

So figure out how to handle dates so that it reads well,
factor out the initial solution data to a fixture
and add to the parameterisation for the rest of the learning phase cases - there are ony three more.

~~~~~~~~~~~~~~~~
2022-07-01 22:55

I've finished the implementation of ZugTrainingPosition.
Added a set of dates that currently cover all circumstances.
And factored the due date generation logic into a member function.
These due dates are randomised - so perhaps these tests should be run sufficiently many
times.
Or rather, the date generation should be tested.
And since it's a private function, it should therefore be factored out into a new class.
This helps to keep classes the right size.

~~~~~~~~~~~~~~~~
2022-07-02 16:15

Okay, so now we've got all the pieces in shape for the training positions, solution data,
and queue.

Next, we need to work on the architecture that fills the queue.
That will be the responsibility of the entry point of training, when selected by
the user.

Actually, the next thing we should do is test and implement the ZugPresenter class.

~~~~~~~~~~~~~~~~
2022-07-02 17:50

Good progress with the presenter class.
The next steps:
1. Complete the tests for the input and output for non-new
2. Add the board drawing to _present_front() and _present_back()

~~~~~~~~~~~~~~~~
2022-07-03 12:50

The presenter class looks good.
The next stage then is to write the part that operates on a commented PGN.

What do we want to do?

1. Populate the Queue from a commented PGN
2. Update the solution statuses based on the date

Let's first try to understand how the current code does this.

Invariants:

1. The LEARNING_STAGE_* statuses are only in operation during a training session.
A training session should be a class.
It has direct access to a PGN, its training file
It creates and populates a queue, then calls play on it.
It is responsible for saving the changes to the PGN.

So it should provide a function .train()

Its constructor should be something like:

ZugTrainingSession(pgn=/path/to/PGN)

Perhaps the first thing we should do is get the solution nodes into a set.
Bearing in mind that this is specific to position-based training.

So we need a base class TrainingSession and a derived class PositionTrainingSession
What will the interface to this class look like?

1. Get all of the solution nodes into a set
2. Update their statuses if necessary:
   - what constitutes necessity here? perhaps that the last access date is in the past
   - perhaps we can assume that a training session always leaves the statuses in the
     correct state. This is basically NEW vs INACTIVE. REVIEW status doesn't change 

Perhaps it's actually simpler if there are only two statuses in the PGN,
INACTIVE and REVIEW.

We treat the learning phase statuses and training *session* concepts.
Maybe the training session should be responsible for updating the PGN, not the
training position item.

This could cause a problem if a session is terminated when a REVIEW card has gone back in to the learning phase..
Or will it?
It will just remain in review if it has not been completed

Hmmm, surely we can have the TrainingSession insert the NEW statuses at the point of queue generation.

So a PGN will only ever have INACTIVE and REVIEW written into it anyway;
unless a training session is allowed to be stopped early.
In which case it's the session's responsibility to handle the nodes' comments
and update them accordingly.

So, let walk towards that from the Training Session's interface.
We first need to get all the solution nodes into a list.
So let's delegate this to ZugRoot.
Something we can implement now.

~~~~~~~~~~~~~~~~
2022-07-03 14:56

It turns out that here is the point where we need to consider the blunders business.
At least, even if we don't include these into the solution set now, we need to be
aware that items in the solution set might need to be played from the perspective
of the opponent.
This is a nice feature, so we may as well build it in now.

I've produced some PGNs that should capture all the essential cases for 'solution
collection'
So now the challenge is to TDD that solution collection.
I'll start with the most simple case,  a single line.
It seems that it may be useful adding the perspective to the root data, as this can
no longer be determined from the solution.

~~~~~~~~~~~~~~~~
2022-07-03 20:00

Solution collection has gone excellently.
Now that I have solution collection, I can start to build the TrainingSession class.

But first, a bit of clean up in the ZugRoot tests should be done.
In particular, a fixture for the root_data should be introduced, and the magic values
replaced by named constants.

~~~~~~~~~~~~~~~~
2022-07-03 21:42

I've cleaned up the unit tests.
So we're all set to go with the TrainingSession class.

I think this should be subclassed from a common base, as Line and Position-based training
must have common functionality - .train() for example.

I should also think about putting the tests into classes.
I think this would work nicely, one class per test.

~~~~~~~~~~~~~~~~
2022-07-06 16:24

Now I've got the best part of an evening to work on the trainer.
The next thing to do is implement the training session class.
One big decision is whether the training session should open the PGN, or not.
And therefore, whether it should be responsible for writing the changes.

I'm not sure.
I'm thinking not.
It should just be given the ZugRoot, from which it can do everything.

I tnink the files should be opened by the menus, and saved when the menus exit.
It makes sense that the item menu is really the item manager.
So it should have sole responsibility for the file I/O.

So let's go with that.

So what do we expect from the class?

We want to say 'go and train'.
And tell me when you're done.
Do we really need anything else from the class?
Not really.

But someone needs to provide the functionality to determine the statuses of solutions.
That shouldn't be the job of the training session, as it will need to be done e.g.
at startup.

So the training session should assume that the Root is in shape when it is given it.
This makes the class's job much easier to conceive and to test.

ZugRoot should have a method that returns a list of all solutions with a particular status.
So we can use that within the class to build the queue from the Root.
Then we just need to call play() on the queue.

It will fill its own queue.
We should next build the functionality that updates the PGN file - if necessary.

We should house this in a class that represents abstractly the training 'chapter'.
Chapter can be small (analysis of a few lines stemming from an endgame position)
or larger (a substantial repertoire in the sicilian).
A Chapter should be able to:

read the pgn and deliver its ZugRoot
write a pgn from its ZugRoot
update the ZugRoot - meaning updating the statuses of all Solution nodes, and the
metadata. But only if the last access date is before today.

Reading and writing should be indpendent of updating.
That is, updating should take place on the python objects.

A chapter should do the following:
1. initialise a ZugRoot from 

~~~~~~~~~~~~~~~~
2022-07-09 14:56

Making progress with this now, but it has been difficult.
There have been some ad hoc changes to unit tested classes and their tests,
along with a departure from TDD.

But the interface offered by ZugChapter, via ZugPositionTrainer, is nearing completion.

Now it would be useful to have a instance method offered by ZugRoot called reset().
This methods sets all comments to their defaults.
Then we can open a pgn via Chapter, call reset() on it to populate default comments,
then save the pgn via. Chapter.save().

From there we can start to see whether we can indeed positionally train a chapter.

~~~~~~~~~~~~~~~~
2022-07-09 16:18

Now I see what the architecture should look like, at least from Chapter down.
The Chapter is responsible for saving.
It looks at the ZugRoot, which lives in a different space, and decides how to set
the comments on game and the solutions.
Then it writes the pgn file.

Let's implement this save.
Then we need to think about whether parts of ZugTrainingPosition should factored into ZugSolution.
I think so.
But let's handle saving first.

The essential point is that there are ZugSolutionStatuses (UNLEARNED, LEARNED) and
ZugTrainingPositionStatuses (NEW, LEARNING_STAGE_*, REVIEW) etc.

It should be clear why there is a difference. TP statuses should be mapped down onto
solution statuses during saving.

~~~~~~~~~~~~~~~~
2022-07-09 17:53

Okay, so we have fairly decent interfaces for Chapter and Traininger, which
is subclassed by PositionTrainer.

Now we need to work downwards.

~~~~~~~~~~~~~~~~
2022-07-15 18:38

Looking at the code now, we need to add unit tests for the classes which have been
refactored.

Then, when this is done is the nicest possible way, create some actual chapters.
In fact, create some collection, categories, chapters.
One for a set of endgames, another based on the PGNs I must have for openings;
Grunfeld would be a good example, to see how the setup reacts to a large

~~~~~~~~~~~~~~~~
2022-07-25 09:43

The unit tests for the dates class have been completed.
Now we need to put similar unit tests in place for the other classes.

~~~~~~~~~~~~~~~~
2022-07-25 14:00

I've used json serialisation and dataclasses to significantly simplify the
implementation of ZugRootData.
The next stage then is to apply the same treatment to ZugSolutionData.
This shouldn't take more than an hour.

It took forty minutes.
I've put the common logic of the two dataclasses into a base class.
All that is defined in the derived classes is the fields.

~~~~~~~~~~~~~~~~
2022-07-25 14:40

Now we'll look at the ZugRoot class.
It's probably not a good idea to have the ZugRoot class responsible for updating the
comments of the solution nodes.
That should be undertaken by the chapter, which has access to the ZugSolution.

~~~~~~~~~~~~~~~~
2022-07-25 20:11

Some bugs to fix with the from_json methods.
The big issue was that I was using a call to a function as a defualt function
parameter, in this case the function was the class constructor.

~~~~~~~~~~~~~~~~
2022-07-26 07:40

Where are we at?
We're still in the realm of game.py and its unit tests.
There are some parts of ZugRoot that I think don't belong there, so let's delay
that refactoring until we come to ZugChapter.
For now, let's close off the unit tests for the parts that we know belong in ZugRoot.
First question, why is the equality of Data classes failing?
Solved - it wasn't picking up the date fields correctly.

We could probably go back to dataclasses there now, but all we would save would be
the implementation of __eq__, so let's leave it at that.

~~~~~~~~~~~~~~~~
2022-07-26 07:50

Is there any sense in avoiding default values in the tests?
Perhaps there is.
If we use default values, and constructors like ClassName(), then we're not
testing the initialisation of objects.
But it would feel much neater if we didn't need to specify these values in the tests.

Perhaps this is pedantry and wanting to impose a niceness that is unnecessary.
We need to test with concrete values.
It is probably sensible to avoid the defaults, in case the defaults are somehow
used accidentally instead of the initialised values.
That would be a horrible bug to trace.
So let's stick with it.

~~~~~~~~~~~~~~~~
2022-07-26 07:50

Okay, in the interests of moving forward, I'm going to leave the game unit tests as they
are for now, and revisit them in the afternoon.

I think what's needed is:

1) A structure of fixtures that links a root and a solution, with appropriate data for
each, attached to the comments of the chess nodes.
2) Tests for the defaults:
   tests for the default constructors of ZugRootData and ZugSolutionData
   tests for the default values themselves, i.e. ZugDefaults

~~~~~~~~~~~~~~~~
2022-07-26 11:05

It seems that the ZugChapter class is quite hard to unit test.
Does it really need unit testing?
Perhaps a very simple test that is merely for coverage.
But again, we can come back to that.

So what is next?
The ZugQueue and ZugTrainer classes.

~~~~~~~~~~~~~~~~
2022-07-26 11:57

What we have learned in the last hour is:

1) most of the work unit testing ZugQueue, ZugQueueItem, ZugTrainingPosition
and ZugTrainingPositionPresenter have already been done.
2) we should get a working piece of software going, that I can install in a python venv
   it just looks for a chapters folder and cycles through the chapeter,
   training each.

Let's try to get this in place by the end of the day.

~~~~~~~~~~~~~~~~
2022-07-26 13:12

This afternoon:
Create an installation of zugzwang; i.e. clone the repository somewhere else.
Locate those grunfeld PGNs, put some of them in the categories folder.
Hopefully then the trainig will progress through those, and we can test what happens.
We should add some basic formatting to the presenter.
That should be very easy, we have all of this already in the old code.

~~~~~~~~~~~~~~~~
2022-07-26 15:00

Just three hours remaining.
So let's start by creating a some easy graphics.

~~~~~~~~~~~~~~~~
2022-07-26 15:00

Looking good, so let's get the menus up and running.
Then we'll have to get the pause signal into the training somehow.
But that can wait.

I think the menu should read:

ID COV. (*) NAME              NEW DUE LEARNED TOTAL

~~~~~~~~~~~~~~~~
2022-07-26 18:00

So, we have a hastily built Collection, Category, structure with some ZugStats class.
This appears to propagate and collect the stats quite quickly.
Let's see next whether it works on all the Grunfeld openings.

But that's for tomorrow.

~~~~~~~~~~~~~~~~
2022-07-27 08:58

Tomorrow is here.
I'll put all the Grunfeld openings as chapters into the collections folder.

~~~~~~~~~~~~~~~~
2022-07-27 11:23

The menu logic is up and running.
Now I'll factor out the common logic into an abstract base class ZugMenu.
Subclass that into ZugGroupMenu, to handle MainMenu, CollectionMenu and CategoryMenu.
And subclass it separately for ChapterMenu.

~~~~~~~~~~~~~~~~
2022-07-27 11:23

All the menu business is working.
Goals for the afternoon:
1. Allow a training session to be paused
2. Implement the line-based training

~~~~~~~~~~~~~~~~
2022-07-27 17:45

A good day's work today.
All the menu stuff was very fluent.
Getting to the line-based training, I fell back into the old way for a couple of hours.
Why?
I just wanted to see it working.
I should see the unit tests of a nicely defined class passing as 'it working'.
Had I done that, I might have had the lines generated by now.

As it is, the next thing to do is to generate the lines.
I'm quite certain a line should just be a list of nodes.
We won't record any outcomes of line-based training at this stage.
But having access to the nodes seems sensible.

~~~~~~~~~~~~~~~~
2022-07-27 09:22

I've written code for the line generation.
It was similar to the recursive algorithm for solution collection.
It passes the first linear tests.
Now I need to write the tests for the more complex PGNs and hope to see it passing.

~~~~~~~~~~~~~~~~
2022-07-27 11:22

All test for ZugRoot.lines() written and passed.
Now we need to rewrite the code from ZugLineTrainer onwards.
This should not be difficult, but we should pay attention to the presenter.
Why not have a default presenter implementation that displays every position in the line.
When we can check that the lines and queue are correct with integration testing.

Thereafter, work on the presenter and training item.

~~~~~~~~~~~~~~~~
2022-07-27 12:02

The default implementation is already excellent.
Let's add logic that allows to give a verdict of failure after each solution.
Then with the default QueueItem logic, that line should be reinserted into the queue.
And that's it for now.

~~~~~~~~~~~~~~~~
2022-07-27 12:20

Implemented.
So that's the morning's work done.
Time to decide on how to proceed from here.

Probably the way forward is to try to complete the unit testing, one module at a time.
We should try to do this without meeting the urge to refactor.
There may be grounds to restructure the design here and there, for example to
factor ZugRoot.solution_nodes() into ZugPositionTrainer, and ZugRoot.lines()
into ZugLineTrainer().
But there is no need to do that now - the software works.
It might be worthwhile if we want to introduce new features.

Let's start with getting the game unit tests to work with .chp rather than .pgn

~~~~~~~~~~~~~~~~
2022-07-27 15:22

The game.py unit tests are in shape now.
I've also added a margin to the board so it looks much better now.
What to do with the remainder of the day?
I think we should look at the queue.py unit tests.
We should start with the presenter classes.

~~~~~~~~~~~~~~~~
2022-07-27 16:43

The presenter classes have been unit tested, everything is passing and it looks okay.
Now we'll move on to the queue item classes.
Probably we won't get these done today.
So let's make a start and see whether we can understand what good unit testing looks like

~~~~~~~~~~~~~~~~
2022-07-27 18:00

Done, it's clear what the unit tests should look like.
It must be good, the test body and the parametristions are considerably simpler than
they were before.

Next thing to do:
create the ZugTrainingPositions for the remaining cases:
learning_phase_success
learning_phase_failure
reiew_phase_success

These could be factored into a single test, by parametrising the expected ZugSolution
method that should be called.
Then having 'for method in method if method is not expected_method: method.assert_not_called'

This might be a way forward.

~~~~~~~~~~~~~~~~
2022-07-29 08:43

Let's get the unit tests done for the queues and training.
Then let's go straight to creating a package installing it.

I would like to have a user installation, and a development installation.
It would be great if I can get that happening by the end of the day today.

~~~~~~~~~~~~~~~~
2022-07-29 10:05

queue.py unit tests are complete.

~~~~~~~~~~~~~~~~
2022-07-29 12:05

I've neatened up the repo a bit and pushed it.
What's left?
Not much, the queue tests should be migrated, and then we can delete all of the
old source code.
Let's call that the only job for this afternoon.

Then the next thing to do is to use it!

~~~~~~~~~~~~~~~~
2022-07-29 14:21

Two things:

1. New remaining is not being reset daily. This should be added the chapter
   constructor
2. I think ZugRoot and ZugSolution are redundant. Perhaps consider factoring them out.
   Everything that ZugRoot does belongs in Chapter. ZugSolution is very similar to
   ZugTrainingPosition

Perhaps a good solution is to have ZugRoot renamed as ZugGame, ZugSolution and
ZugBoard as the only classes facing 'chess'.
They essentially replace the chess classes Board, Game and ChildNode.

We should then have a function somewhere that takes a pgn filename and returns
a ZugGame.

But best to do this slowly, one refactor at a time.

~~~~~~~~~~~~~~~~
2022-07-29 14:21

We should make ZugGame (formerly ZugRoot) and ZugSolution 'transport classes', in the
sense that they hold no data themselves, they merely exist to get the data from
the chess GameNodes. They provide update methods, so that classes that wish to
interact with a chapter's back end data structure have a good interface for doing so.
For ZugSolution these are the learned, recalled, forgotten methods, along with a reset,
and a generic update. For communicating the back end data, ZugSolution returns a
ZugSolutionData object.
For ZugGame these are the reset, generic update and update_learning_remaining.
Learning remaining is unique amongst the stored data, in that it may change overnight in
an abstract sense, but not 'on paper', and hence needs to be checked and updated
regularly.
Both of these classes then share a lot of common logic, so there's a good opportunity
for a powerful base class.

~~~~~~~~~~~~~~~~
2022-07-30 10:56

Some updates:

1. Sort chapter, categories, collections in alphabetic order - D0ne
2. We're not updating the last access, so learning remaining is getting updated when
   it shouldn't do - Done
2. Number of lines left in training session printed to screen - but this will be easier
   with the UI
3. Statistics for line-based training: and a programme - line based training preceeds
   position-based

~~~~~~~~~~~~~~~~
2022-07-30 15:26

Fixed a couple of easy bugs - the unit tests for ZugRoot need updating.
Now I'll get the comments binded to the Roots and Solutions, and sort out the
curly vs straight braces at the same time.

~~~~~~~~~~~~~~~~
2022-07-31 09:02

I think forgotten positions are causing a problem with learning remaining.
Probably they go back into learning, and when learned the learning remaining gets
decremented, and then ends up below zero at the end of the session.

So, we perhaps we need a separate status for forgotten positions.
The simplest thing to do is to set them as unlearned, they will get picked up tomorrow.
Or we have statuses REMEMBERING_STAGE_1 and REMEMBERING_STAGE_2, and we don't decrement
learning remaining when the fogotten positions get remembered.
So we'll need a Solution method '.remembered()'

Let's try to get that far with the unit testing for ZugSolution() and ZugRoot()

~~~~~~~~~~~~~~~~
2022-08-01 21:25

We should put constraints on the allowable values of data into the data classes.
This will be done via @property and getters.
Then we can unit test those.

e.g. success and failures must be set with non-negative integers;
     last_access must be set with a date <= today; etc.

This will be a really neat feature, it takes that error handling out of the root
and solution classes.

~~~~~~~~~~~~~~~~
2022-08-01 22:10

Good progress, the tests for ZugRoot have been completed.
What next? Well, we need to rename that class ZugGame.
Then we need to factor the unit test for _bind() out of TestZugRoot and into
TestZugGameNodeWrapper, as it belongs there in the base class.

Then we need to write analogous unit tests for solution, including implementing
a method remembered().
Then we need to factor the solution set and lines set collection into ZugChapter.

So quite a lot of work for this update.
But it will all be worth it.

~~~~~~~~~~~~~~~~
2022-08-04 20:26

Getting back to this for a few hours tonight.
Let's start with the analogous tests for Solution.
We'll make it tonight's goal to get this file tested, cleaned, with the remaming
and refactoring.

Okay, I've done the unit tests for solution..
But I now feel like bind() belongs in the data classes, which should be linked to
a node..
But perhaps I only want this because I really would like to be able to set and access
the data for the unit tests.
Having to set and check the comments is sensbible if you want the data hidden in the
class, you want the class to manipulate comments and provide an interface for that.
So you set the comments and watch the interface manipute them correctly.

The main draw back is that the comment is large. Typically the interface makes small
changes to particular fields and we want to test that in a good set of cases.
Using comments makes those tests unreadable.
So maybe it's just a good idea to make that data accessible.
Or really, perhaps it's better to have the manipulating class looking at python fields
that are python data types, rather than a json string whose manipulation it delegates
to the data class.

Yes, I like much better the idea that the data class is the node wrapper's view of
the node comment. It's better to look at dictionary than a string. That rings a bell?

Perhaps the issue is that really, there should only be a single class.
The nice thing about the data class is that we can use __dict__ to write the json.
So let's not meddle with those.

So lets have a think about this.

~~~~~~~~~~~~~~~~
2022-08-07 15:24

Let's focus on getting the software working, we can rewrite the data layer if necessary.
So there are two things to do:

1) Get the 'forgotton' track of a training position up and running - Done
2) Factor the line and solution set generation out of ZugRoot and into ZugChapter

I've factored line and solution generation into a new class of ZugChessTools.
The test setup makes more sense now (it doesn't need to go through ZugChapter).

Time now to rewrite the chapter constructor, and to rethink how to save and update,
now that the bind logic is in the node wrapper classes.

~~~~~~~~~~~~~~~~
2022-08-07 20:00

We now appear to have a working version of the trainer again, but there are still
a couple of things that are a little messy.

1) The classes ZugTrainingPosition and ZugTrainingLine are in queue.py
   They should be in training.py, and their associated unit tests too.

2) The ZugChapter constructor still feels a little messy

3) There are failing unit tests

Let's try to sort 1 and 3 out.
1 is now sorted, I've put them into fresh files positions.py and lines.py
Let's have a look at the extent of 3

~~~~~~~~~~~~~~~~
2022-08-15 19:39

Now I'm going to try to write a basic UI.
It will display the starting position of the chess board and allow the user to make
legal moves.

So, we have a button that looks like a chess square, and sends it square name to
get set by a label when clicked.

Now we need to create function that handles all the input from these squares,
and tries to create a move from them.
If a legal move (from the starting position) is made, the label should read legal move.
Otherwise it reads illegal move.

And at the same time to style the buttons, so that they look better

~~~~~~~~~~~~~~~~
2022-10-02 21:21

The UI has to wait.
It was stopping me using it.
Recently I've got some endgames in there.
I think it would be a very useful feature to have multiple training trees in a
single PGN.
That will definitely help with the structuring of material, especially for endgames.
Endgames will not grow much, if at all.
And frequently there are related positions that aren't tree-connected.
So very useful to be able to do this.

One difficulty, when converting, we might have training positions from different
perspectives in the same PGN.
But we can always convert individually and then concatenate, if that's a problem.
Shouldn't be too difficult to build this feature in.

~~~~~~~~~~~~~~~~
2022-10-08 20:00

Working on the multiple games in one PGN.
The first thing to do is to figure out how chess reads the games - how do
we figure out there are no more games?

Then we read the games into a list - or maybe a dict mapping games to roots.
The lines and positions of a chapter do not need to be indexed by root.
So this should be fairly simple.
All of the logic changes should be kept in the Chapter class.

One minor thing is that the perspective has to be set on the root now, not on the
chapter.
Let's fix that afterwards.

Oh, it turns out the perspective is in the root data.
Argh, the real complication is that learning remaining etc belong on the chapter..
That is annoying.
An easy fix is to put the learning remaining etc on only the first root.
Subsequent roots need only a perspective.
They will have the learning remaing but it will never get called.
But this is a bug waiting to happen..

So let's synchronise the learning remaining on all roots.
Until we figure out a common location in the PGN standard to put it.

The trainer doesn't use the roots of the chapter. So nothing has changed there.

On balance, I think the easist thing to do is have the solution linked to a list
of roots, rather than just its own root.
Then it can update all roots at the same time.
Then if we want to refactor that later, we can do.

~~~~~~~~~~~~~~~~
2022-10-08 20:00

Change of heart - actually I think the easiest thing to do is to link the solution
nodes to the first root in the list.
That way, we don't need to chage the ZugSolution at all.

~~~~~~~~~~~~~~~~
2022-10-08 23:30

The feature is in place.
Now I'll use that branch when training to test before merging into master.

~~~~~~~~~~~~~~~~
2022-10-16 13:59

The feature appeared to work, so I've merged it into master.
For today, there's a few things I'd like to put in place:

1. Clean up the repo, by deleting all redundant files
2. Assess the need for a ZugRoot on additional games in a .CHP
3. Have the software able to open a .pgn on the fly, and save it as a .chp
4. Have the software ignore files that are not .chp

Okay, the good thing is that we now have all files accounted for, and all unit tests
passing.
So let's take a look at the game.py and test_game.py and assess the need for multiple
ZugRoots.

Also let's get flake8 on the go.
Can it point to unused variables?

Black code formatter is brilliant.
Okay, now it's time to figure out why we have redundant tests in that file.

I have a feeling that the fixtures used in this file need a clean up.

~~~~~~~~~~~~~~~~
2022-10-16 18:48

Made quite a lot of progress with the test_game file.
Now it's clear that quite a few of the ZugRoot tests use a root which needs to
be set up from a game node that already has an appropriate comment.

Perhaps we shoudn't write the comment as a string in the tests -
Rather create an instance of the appropriate data class, and call its json method.
The issue is that the outputted json has curly braces, it needs square ones.
So what's the best way to get around this?

The data class shouldn't really be responsible for squaring the braces.
We could set up the comment with bind().. but that would require the wrapper constructor
to be able to accept a naked (uncommented) node.

Given that's the behaviour we want as default, perhaps we could try to TDD this into
the GameNodeWrapper class.

As for now, let's leave it as is, and finish off the tidying of the test_game.py.

~~~~~~~~~~~~~~~~
2022-10-17 22:28

Now I'm going to go finish the clean up of test_game.py
That's done.
So what do we want to achieve now?

I'd like to be able to load a pgn file without comments, and have ZugZwang
automatically set it up.

This means that we'll try to create ZugGameNodeWrappers whose GameNode does not
at first have a comment.
In that case, we should generate the default data and bind the comment straight away.

How should we determine that a node is naked?
We should insist that it has no comment.
It's tempting to try a json decode, and overwrite the comment if that fails.
But we might miss an actual decode error, which would be bad.
So let's say, if there is no comment on the node, create default data and bind.
We can actually do this in the base class!
Awesome.
Let's write the tests first.

This has thrown up another subtletly about the data classes.
The from_json method should be capable of filling in missing values with defaults if
they are not supplied.

~~~~~~~~~~~~~~~~
2022-10-17 22:28

Perhaps it makes sense to factor the json conversion out of our classes, and have the
data class deal only with dicts.
The fact that they handle json input is really a convenience that they provide
knowing that they are employed by the GameNodeWrapper.

But since the wrapper takes care of the binding, and also the braces replacement,
it makes sense that it should also take care of the json dumping and generation.

In fact, all of that can go into bind and __init__
I think that's a good call, so let's go for it.

Okay, I've reached a good stopping point.
We'll need to test the new tools classes - but that should be easy.

A ton of other unit tests are failing, so we'll need to address those.
Probably there a couple of easy and obvious changes needed in the tests and/or
source code for the derived classes.

But I'm happy with the implementation of the base classes at the moment.

~~~~~~~~~~~~~~~~
2022-10-19 10:00

Having an hour to neaten things up.
Just had a very annoying bug - I accidentally deleted the return value of a json
tools function.
Now, that would have been easily spotted had I unit tested those tools.

So the very next thing we should do is to unit test those tools.

~~~~~~~~~~~~~~~~
2022-10-19 11:00

Writing the tools unit tests.
Done.
Okay, now let's go back to the game base classes.
Do their tests run as expected? Yes.
The derived data classes? Yes.
The derived wrapper classes?

ZugRoot has one failure.

The wrapper's data is not being set properly via the node's comment.
So let's investigate that.

It was an interesting bug, once again pytest allowing you to use names that aren't
defined.
That is such an annoyance.

Anyway, all the tests are passing now.
The next task is to write methods in the data base class:

    to_string(), to go straight to the game comment,
    		 let's call this the Zug serialisation format

    from_string() and from_dict() make the data class from dicts and ZugStrings

Then we can write these into the unit testing to make it clearer.
And then use them in the wrapper code too.

We should unit test those methods first.
This shouldn't take more than a couple of hours.

~~~~~~~~~~~~~~~~
2022-10-19 21:43

So let's get these methods tested now.
We have these methods and they are unit tested.
So the next thing is to look at the existing unit tests and see whehter we
can simplify them.
Then to look at the existing logic with the same motive.

~~~~~~~~~~~~~~~~
2022-10-20 18:01

The unit tests are all accounted for.
The next things are:

1. what's going on with having essentially one root per file?
2. the secondary roots will be empty, so we should make that explicit.

There is no harm in having this comment on the non-primary roots unless the
first game is somehow deleted, then we'll use the stats on the second game - but they
won't be valid.

Let's leave this for the moment.
What we want to work towards is having PGNs modifiable elsewhere, and automatically
populated.

We should introduce an exception for when the comment is not recognised.
This could be handled by either the ZugData or the ZugGameNodeWrapper classes.

It should probably be handled by both.
The ZugData class can reject the comment.
It could inform the caller of various error cases:

1. It is not a valid ZugString
2. It contains bad arguments

Error handling has been added to the ZugJsonTools class

Consider adding some to the ZugStringTools class.
These check that the to_square_braces and to_curly_braces receive correctly delineated
strings.

Good, the we've got some error handling in the tools classes.
The next thing to do is to add that error handling into the GameNodeWrapperClass.

That has been done.
So now let's have a think about what to do with Chapter.
The end goal with Chapter is this:

- if you modify the PGN, without ediing comments, it will just work.
- it will also be backwards compatible.

What we don't want:

- overwriting badly formed comments (could lead to hard to trace bugs)
- support for automatically erasing deprecated fields - but we could do that later

So we want chapter to raise an exception if it encounters ZugGameNodeWrapper errors.

So we have absolutely nothing on chapter test - so let's think about how to test
this, and come back to it.

~~~~~~~~~~~~~~~~
2022-10-21 08:41

It looks like stats is not a property.
Let's sort that out.

In terms of unit testing chapter -  maybe the only way forward is to hit it with
a bunch of chapters, and then check its member variables: solutions, lines, stats, etc.

Hmmm.. the set of solutions, that comes via ZugChessTools where all of that is tested.
We don't want to redo those tests here.
So what is the real functionality that Chapter implements, rather than delegates?

Here's a nice idea - we test the Chapter class, we're allowed, or even encouraged,
to use the tools of the other classes.

So we can create some chapters as raw files.
Use chess and ZugChessTools to get their roots and solution sets with minimal fuss.
And then calculte their stats, etc. and just check that the constructor does its job
correctly.

So which cases do we want to check?

1) A completely empty Chapter - if we can even create one?
2) A chapter with only one (non-trivial) game
3) A chapter with multiple (non-trivial) games 

I'm not sure we need to do anything beyond that.
Do we need to check that a naked PGN is really turned into a chapter?
Or that a bad Chapter (i.e. incorrectly commented) returns a sensible error?

Yes, I think that Chapter should really handle those errors well, because they
are bound to occur.

One question is about the design of stats updates.
The stats are usually displayed on the Chapter's display.
If we ever intend to make that display visible alongside the training display,
we would want the changes in those stats to be accessible from the training session
And then presumably from the queue, etc.

Perhaps the training session needs to keep hold of its own stats.

Or perhaps a chapters stats are a dedicated object, with methods, or is that
overly engineered?
It would allow the chapter stats to be synced in real time to a training session.
Could this present problems with forgotten positions?

What stats would we like to present during a training session?
Total number of positions remaining, breakdown into new, learning, recall?

With line based training it's easy, total number of lines remaining.
Perhaps we can count the number of positions in each training status.
Then decide what to present in the presentor.

~~~~~~~~~~~~~~~~
2022-10-21 08:41

Presently then, we need to create our mock .chp files.
Can we use those that we have already?

It appears that we have chapters and naked PGNs in two folders.
Test_game appears to have the location - but it shouldn't need them.
Let's fix that.

Done.
So it looks like we already have enough to get what we need easily.
We just want empty, naked, partially-naked and naked multi-game.
The question is where to put them.

I'm going to put them into dedicated categories - I think that makes the most sense.

Actually, there's an issue with automatically stuffing up a naked PGN: it's not
clear which perspective to work from.

So - rather than try to do this automatically, we should expect chapter to get perfectly
formed chapters.
Then we can factor the checking logic into a method.
Essentially what we want here is error handling.

So let's have a rethink on this.

Perhaps all we really want to insist is that the PGN root has a perspective.
We can do literally everything else after that.

So then the script with which we prime a naked PGN to be ZugZwang ready literally
just has to assign that perspective.

In fact, maybe it is just easier to not do anything at all here - have no special
requirement that the root has a perspective.

It's a tricky one.

Let's go with no assertions at the moment - we can always introduce them.
Then we'll have the PGN -> CHP script just insert the perspective.
That serves as an integration test that everything is working.

Okay, so we've got a template for the chapter tests.
We want then to add one where the solution nodes have incomplete non-default data.
Becuase the current tests would pass if we just overwrote everything with the defaults.

***********************
I've just noticed that an empty PGN breaks the training.
So we need to unit tests empty queues, or something similar.


How do we split up an existing chapter into constituent parts?
My current chapters in, for example, the English are too large, and should be split up.
I think that the optimal size for a chapter is around 50-60 positions.

We could strip it down but not get rid of the inevitable repeated stork.
That might be annoying - but maybe it isn't.
It will just be a feature of my repertoire.

It would be excellent to have the computer play your repertoire against you.
We can bring the whole repertoire together by cataloguing the root positions.

~~~~~~~~~~~~~~~~
2022-10-22 17:01

Now I'm going to try to break up my existing repertoires into pieces.
Then try to structure the opening repertoire into collections, categories, and chapters.
And then try to fill some of them in.

And also, get going with the endgames.
I think if I dedicated two hours to the endgames I could get most of the rook endings
and pawn endings that I've worked on into chapters.

But first, let's try to break up the Grunfeld.
Starting with the Reti and the English.

I've broken up the Reti and English into smaller chunks.
Now we have to set them all with perspective black, and see whether we can open them,
and check that the opening of them adds default training data to the file.

~~~~~~~~~~~~~~~~
2022-10-22 20:22

Everything appears to be working.
One question this has thrown up is the saving policy.
The PGN is only written when a training session ends.
So if you launch with a naked PGN, you'll get the right stats shown, but the default
comments won't be written to the PGN.
That's fine actually.
Maybe it's best just to leave it that way.

It might seem better to write the defaults comments when it's first encountered.
Then we'd have to detect which ones needed saving - or save every one as its opened.

That might become significant if we have a lot of chapters.
So let's not do that.

So we're all set to start continue breaking down the Grunfeld repertiore.
As for now - let's start building the other areas up.

I also added filtering to the list of chapters.
Only files ending .chp will show up.

Okay, we've started the process.
There's a lot of work to do here.
But we should start building this up.

We'll end up with a cracking repertoire.
The excellent news is, HIARCS will open a .chp file!
Awesome, so we can use that to add moves.
Best keep some regular backups.
I think that should be the next development feature: dailly backups of the collections;
keep for the last week.

Now for some endgame PGNs.

~~~~~~~~~~~~~~~~
2022-10-22 20:22

Now I'm going to write all of the pawn on the sixth rank positions into one pgn.
Then we can think about splitting them.
And also have the prepare PGN script (and perhaps the chapter constructor?)
replace double blank lines with a single one.

The issue is that I want to use HIARCS to edit these files.
It sticks in these extra blank lines, so I won't be able to open them in Zugzwang.

Anyway, for now let's build these PGNs so that they are usable.

Perhaps an ad-hoc script to format the chp/pgn files is better than hitting the
chapter constructor with some hacky logic.

There comes the possibility of using ?! as dubious move - that is one that makes
the position harder to win or to draw, but doesn't change the evaluation.

In such a position, the trainer should teach the correct moves in a separate line.
Let's encode them this way.
It will be a lot easier to keep the material togehter.
Otherwise we would need to start a new game for every such subtlety.

Interestingly, HIARCS doesn't seem to be putting the extra newlines in atm.

And I'm using !? for a move that is essentially of equal stature to the main move.
So perhaps when there are two conitunuation of equal merit.

It can also be used to mark a swindle attempt.
So that when the position is drawn, and the training is for black to draw, you can
also ask the student to find the best tries for a win.

We still have quite a lot to put into PGN here.
There is another question - do we want to use exclams to denote unique moves?
It would be interesting to see wheher Dvorestsky uses this convention.

~~~~~~~~~~~~~~~~
2022-10-23 15:26

Let's finish off the current endgame chapter, sixth-rank, and then try to implement
the interesting move feature.
This only affects an interesting move for the training side, not the opposition.

We've got the sixth rank PGN up to but not including the exercises.
We need to first unit test this idea of putting in iteresting and dubious moves
into the players candidates.

Rather than switch the perspective, these should create a new lines starting from
any following problems.
So these moves are not themselves solutions, but they lead to problems.

Having !? on a non primary candidate is a bit bizarre.
If you're winning, then why learn a sub standard move?
Well because the resulting position might be of practical relevance.

So we should just have these moves contibute the recursio, but not added as solutions.
It should be fairly easy to get the lines and solutions sorted.

Unit tests for solution and line sets with alternatives are in place.

We should write down exactly what the specification is for our chapters.
So far we have problems, solutions, blunders and alternatives, which is enough
to specify quite a large range of behaviours.

There are likely some edge cases that we haven't covered with the unit tests.

~~~~~~~~~~~~~~~~
2022-10-28 19:10

I'd like to implement a couple of easy features.
The first - some idea of how many training items (lines or positions) are remaining
in the session.
Second, keep track of the number of complete line-based training sessions per
chapter.
Then display that in the category menu.

These should be fairly easy to implement.
I think the queue should just print how many items it has in it.
Or rather, it passes that to the queue item which passes it to its presenter.
Not sure.

Probably the former actually.
Later on, if we have a UI, we'd have the queue item present inside the queue window.
So probably it's better design-wise for the queue to own it.

~~~~~~~~~~~~~~~~
2022-10-28 21:35

We could also use a standalone clean-chp script, which essentially resets the
stats.
This would eventually be an option in the UI.
So let's put that together now.

~~~~~~~~~~~~~~~~
2022-10-30 14:52

Now I'm going to implement three things:

1) training remaining printed in the queue
2) number of complete line training sessions
3) radius of randomness in queue reinsertion

For the first, let's see what the unit tests assert

~~~~~~~~~~~~~~~~
2022-10-30 21:14

We need to sort out the insertion at queue filling - that should be one-by-one.
That should be easily sorted in the _fill_queue method.










